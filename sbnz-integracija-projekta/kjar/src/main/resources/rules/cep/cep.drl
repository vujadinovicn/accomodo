package cep;
import java.util.HashMap;
import java.util.Collections;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.Map.Entry;
import java.util.stream.Collectors;
import java.time.LocalDateTime;
import com.ftn.sbnz.model.models.Booking;
import com.ftn.sbnz.model.models.Traveler;
import com.ftn.sbnz.model.models.Discount;
import com.ftn.sbnz.model.models.Review;
import com.ftn.sbnz.model.models.Listing;
import com.ftn.sbnz.model.models.DestinationFlag;
import com.ftn.sbnz.model.models.TagFlag;
import com.ftn.sbnz.model.models.Tag;
import com.ftn.sbnz.model.models.AccommodationPoints;
import com.ftn.sbnz.model.models.AccommodationRecommendation;
import com.ftn.sbnz.model.models.AccommodationRecommendationResult;
import com.ftn.sbnz.model.enums.BookingStatus;
import com.ftn.sbnz.model.enums.EmailNotificationType;
import com.ftn.sbnz.model.events.BookingAcceptedEvent;
import com.ftn.sbnz.model.events.BookingDeniedEvent;
import com.ftn.sbnz.model.events.ListingViewedEvent;
import com.ftn.sbnz.model.events.BookingEvent;
import com.ftn.sbnz.model.events.BookingEmailEvent;
import com.ftn.sbnz.model.events.DiscountEmailEvent;
import com.ftn.sbnz.model.events.NegativeReviewEvent;
import com.ftn.sbnz.model.events.ReservationCanceledEvent;
import com.ftn.sbnz.model.events.AddedListingEvent;
import com.ftn.sbnz.model.events.FetchListingRecomendationEvent;

import org.kie.api.runtime.rule.QueryResults;
import org.kie.api.runtime.rule.QueryResultsRow;

import com.ftn.sbnz.service.services.interfaces.IListingService;

import java.util.Date;

global java.util.Date dateNow;

global IListingService listingService;

declare MaliciousTravelerEvent
    @role(event)
    travelerId: Long
end 


declare OverlappedBookingsEvent
    @role(event)
    @expires(2m)
    firstBookingId: Long
    secondBookingId: Long
end 

declare RecommendTrendingAccommodationEvent
    @role(event)
    @expires(1m)
    loginTimestamp: LocalDateTime
end

// =========================================
// BOOKING RULES - FORWARD

rule "Send notification to owner after booking event"
    no-loop true
    when
        $BookingEvent: BookingEvent($bookingId: bookingId)
        not BookingAcceptedEvent(bookingId == $bookingId)
        not BookingDeniedEvent(bookingId == $bookingId)
    then
        insert(new BookingEmailEvent(null, null, EmailNotificationType.BOOKING_CREATED));
        System.out.println("Posalji notifikaciju owneru!");
end


rule "Booking accepted by owner"
    no-loop true
    when
        $bookingAcceptedEvent: BookingAcceptedEvent($bookingId: bookingId)
        $booking: Booking(id == $bookingId, 
            status == BookingStatus.PENDING,
            $listing: listing,
            $traveler: traveler
        )
    then
        modify($booking){
            setStatus(BookingStatus.ACCEPTED)
        }
        //insert(new BookingEmailEvent($traveler.getEmail(), $listing.getTitle(), EmailNotificationType.BOOKING_ACCEPTED));
        System.out.println("Posalji notifikaciju traveleru da je booking prihvacen!");
end

rule "Booking denied by owner"
    no-loop true
    when
        $bookingDeniedEvent: BookingDeniedEvent($bookingId: bookingId, $reason: reason)
        $booking: Booking(id == $bookingId, 
            status == BookingStatus.PENDING,
            $listing: listing,
            $traveler: traveler
        )
    then
        modify($booking){
            setStatus(BookingStatus.DENIED)
        }
        insert(new BookingEmailEvent($traveler.getEmail(), $listing.getTitle(), EmailNotificationType.BOOKING_DENIED));
        System.out.println("Posalji notifikaciju traveleru da je booking odbijen zbog: " + $reason);
end


// =========================================
// OVERLAPPED BOOKINGS - CEP

rule "Detect overlapping bookings"
no-loop true
when
    $booking1: Booking($id1 : id, status == BookingStatus.ACCEPTED,
        $locationId: listing.location.id,
        $traveler1: traveler,
        $startDate1: startDate,
        $endDate1: endDate
    )
    $booking2: Booking(this != $booking1, $id2 : id, status == BookingStatus.ACCEPTED,
        listing.location.id == $locationId,
        $traveler2: traveler,
        $startDate2: startDate,
        $endDate2: endDate,
        (
            ($startDate2 after[5s] $startDate1 && $startDate2 before[5s] $endDate1) ||
            ($endDate2 after[5s] $startDate1 && $endDate2 before[5s] $endDate1) 
        )
    )
    not (OverlappedBookingsEvent(firstBookingId == $id1, secondBookingId == $id2))
    then
        insert(new OverlappedBookingsEvent($id1, $id2));
        System.out.println("Bookings are overlapping!");
end

rule "Handle overlapping bookings if there is less than 7 days for one of bookings"
no-loop true
when
    $event: OverlappedBookingsEvent($id1: firstBookingId, $id2: secondBookingId)
    $booking1: Booking(id == $id1)
    $booking2: Booking(id == $id2, $startDate2: startDate, !($startDate2 after[7d] dateNow))
    then
        modify($booking2){
            setStatus(BookingStatus.DENIED)
        }
        // insert(new BookingEmailEvent($traveler.getEmail(), $listing.getTitle(), EmailNotificationType.BOOKING_DENIED));
        System.out.println("Booking with id: " + $id2 + " has been DENIED!");
end

rule "Handle overlapping bookings if there is more than 7 days for one of bookings"
no-loop true
when
    $event: OverlappedBookingsEvent($id1: firstBookingId, $id2: secondBookingId)
    $booking1: Booking(id == $id1)
    $booking2: Booking(id == $id2, $startDate2: startDate, $startDate2 after[7d] dateNow)
    then
        // insert(new BookingEmailEvent($traveler.getEmail(), $listing.getTitle(), EmailNotificationType.RESCHEDULE));
        System.out.println("Send notification to traveler for potential overlap!");
end

// =========================================
// FAVORITE LOCATIONS - FORWARD
rule "Add location to favorite locations on view"
no-loop true
when
    $event: ListingViewedEvent($traveler: traveler, $destination: listing.location.destination)
    not ((Traveler(favoriteDestinations contains $destination) from $traveler))
    $totalViews: Number(intValue >= 2) from accumulate(
        $viewEvent: ListingViewedEvent(
            this != $event,
            traveler.id == $traveler.id,
            listing.location.destination.id == $destination.id
        ) over window:time(3d),
        count($viewEvent)
    )
then
    modify($traveler) {
        getFavoriteDestinations().add($destination)
    }
    System.out.println("Destination " + $destination.getName() + " added to favorites for traveler " + $traveler.getEmail());
end

rule "Send notification to traveler when listing with favorite location is added"
no-loop true
when
    $event: AddedListingEvent($listing: listing)
    Traveler($traveler: this, favoriteDestinations contains $listing.location.destination)
then
    String notificationMessage = "New listing, " + $listing.getTitle() + ", has arrived in one on of your favorite destinations!";
    insert(new DiscountEmailEvent($traveler.getEmail(), $listing.getTitle(), notificationMessage));
    System.out.println("New listing notification sent to traveler " + $traveler.getEmail() + " for " + $listing.getTitle());
end

// =========================================
// FAVORITE LISTINGS - FORWARD

rule "Add listing to favorite listings on view"
when
    $event: ListingViewedEvent($traveler: traveler, $listing: listing)
    not (Traveler(favoriteListings contains $listing) from $traveler)
then
    modify($traveler) {
        getFavoriteListings().add($listing)
    }
    System.out.println("Listing " + $listing.getTitle() + " added to favorites for traveler " + $traveler.getEmail());
end


rule "Notify traveler on favorite listing price drop"
when
    $discount: Discount($listing: listing)
    Traveler($traveler: this, favoriteListings contains $listing)
    // Traveler($traveler: this, id==1)
then
    String notificationMessage = "You're in luck! The booking you were checking out, " + $listing.getTitle() + ", is available at an even better price! Hurry to see the new offer, it ends " + $discount.getValidTo();
    // sendNotification($traveler, notificationMessage);
    System.out.println("Discount notification sent to traveler " + $traveler.getEmail() + " for listing " + $listing.getTitle());
    insert(new DiscountEmailEvent($traveler.getEmail(), $listing.getTitle(), notificationMessage));
end

// =========================================
// NEGATIVE REVIEWS AND MALICIOUS USER - CEP

rule "Traveler gave negative review"
when
    $review: Review(rating < 5)
    not NegativeReviewEvent(review == $review)
then
    insert(new NegativeReviewEvent($review));
end


rule "Assign malicious user flag"
no-loop true
when
    $traveler: Traveler(isMalicious() == false)
    $totalReviews: Number(intValue > 5) from accumulate(
        $review: Review(traveler.id == $traveler.id),
        count($review)
    )
    Number(intValue > (0.8 * $totalReviews.intValue())) from accumulate(
        $negreview: NegativeReviewEvent(review.traveler.id == $traveler.id) over window:time(90d),
        count($negreview)
    )
then
    modify($traveler) {
        setMalicious(true)
    }
    System.out.println("Traveler " + $traveler.getEmail() + " has been flagged as a malicious traveler.");
end


rule "Malicious traveler gave another negative review"
no-loop true
when
    NegativeReviewEvent($traveler: review.traveler)
    eval($traveler.isMalicious())
then
    System.out.println("Malicious traveler is on it again! Alert the admin to double check.");
end

// =========================================
// CANCELATIONS AND IRRESOPNSIBLE TRAVELER - CEP

salience 10
rule "Delete cancelation event if there is already one"
no-loop true
when
    $event: ReservationCanceledEvent($bookingId: booking.id)
    ReservationCanceledEvent(booking.id == $bookingId, this != $event)
then
    delete($event)
    System.out.println("You can't cancel already canceled booking!");
end


rule "Cancel booking for traveler request"
no-loop true
when
    ReservationCanceledEvent($canceledBooking: booking)
    $booking: Booking(this == $canceledBooking, (status == BookingStatus.ACCEPTED || status == BookingStatus.PENDING))
then
    modify($booking){
        setStatus(BookingStatus.CANCELED)
    }
    System.out.println("Traveler canceled the booking!");
end


rule "Flag irresponsible traveler"
no-loop true
when
    $traveler: Traveler(isIressponsible() == false)
    Number(intValue >= 2) from accumulate(
        $event: ReservationCanceledEvent(booking.traveler.id == $traveler.id) over window:time(15s),
        count($event)
    )
then
    modify($traveler){
        setIressponsible(true);
    }
     modify($traveler){
        setDateOfIrresponsible(new Date());
    }
    System.out.println("Traveler has been flagged as an irresponsible one!");
end


rule "Notify admin after irresponsible canceled more bookings"
when
    $traveler: Traveler(isIressponsible() == true, $dateOfIrresponsable: dateOfIrresponsible)
    Number(intValue >= 2) from accumulate(
        $event: ReservationCanceledEvent(booking.traveler.id == $traveler.id, this after[5s] $dateOfIrresponsable),
        count($event)
    )
then
    // insert(new BookingEmailEvent($traveler.getEmail(), $listing.getTitle(), EmailNotificationType.BOOKING_DENIED));
    System.out.println("Administrator notified about irresponsible traveler's additional cancellation!");
end

// =========================================
// RECOMMEND LISTINGS TO TRAVELER - COMPLEX FORWARD

// query "listingsForTraveler" (Traveler $traveler)
//     $listing : Listing() from $traveler.favoriteListings
//     or
//     $booking : Booking(traveler == $traveler)
//     $listing : Listing() from $booking.listing
// end

rule "Extract destination flag"
when
    $event: FetchListingRecomendationEvent($traveler: traveler)
    $favoriteListings: List() from collect (Listing() from $traveler.favoriteListings)
    $previousBookings: List() from collect (Booking(traveler == $traveler))
then
    Map<Long, List<Double>> destinationRatings = new HashMap<>();
    Map<Long, Integer> destinationCounts = new HashMap<>();

    for (Object obj : $favoriteListings) {
        Listing listing = (Listing) obj;
        Long destinationId = listing.getLocation().getDestination().getId();

        //dobaci ocenu za taj listing koju je ostavio korisnik
        double rating = listing.getRating();
        Review review = listingService.getReview(listing.getId(), $traveler.getId());
        System.out.println(review);
        if (review != null) {
            rating = review.getRating();
        } 

        destinationRatings.putIfAbsent(destinationId, new ArrayList<>());
        destinationRatings.get(destinationId).add(rating);

        destinationCounts.put(destinationId, destinationCounts.getOrDefault(destinationId, 0) + 1);
    }

    for (Object obj : $previousBookings) {
        Booking booking = (Booking) obj;
        Listing listing = booking.getListing();
        if ($favoriteListings.contains(listing)) {
            continue; 
        }
        Long destinationId = listing.getLocation().getDestination().getId();

        double rating = listing.getRating();
        Review review = listingService.getReview(listing.getId(), $traveler.getId());
        if (review != null) {
            rating = review.getRating();
        } 
        destinationRatings.putIfAbsent(destinationId, new ArrayList<>());
        destinationRatings.get(destinationId).add(rating);

        destinationCounts.put(destinationId, destinationCounts.getOrDefault(destinationId, 0) + 1);
    }


    int countDest = 0;
    for (Map.Entry<Long, List<Double>> entry : destinationRatings.entrySet()) {
        Long destinationId = entry.getKey();
        List<Double> ratings = entry.getValue();
        double averageRating = ratings.stream().mapToDouble(Double::doubleValue).average().orElse(0.0);
        int count = destinationCounts.get(destinationId);

        DestinationFlag destinationFlag = new DestinationFlag(destinationId, averageRating, count, $event.getTimestamp());
        insert(destinationFlag);
        System.out.println(destinationFlag);
        countDest += 1;

        System.out.println("Created DestinationFlag for destination ID: " + destinationId);
    }

    System.out.println("Number of destination flags created: " + countDest);
    
end

rule "Extract tag flag"
when
    $event: FetchListingRecomendationEvent($traveler: traveler)
    $favoriteListings: List() from collect (Listing() from $traveler.favoriteListings)
    $previousBookings: List() from collect (Booking(traveler == $traveler))
then
    Map<Long, List<Double>> tagRatings = new HashMap<>();
    Map<Long, Integer> tagCounts = new HashMap<>();

    for (Object obj : $favoriteListings) {
        Listing listing = (Listing) obj;

        double rating = listing.getRating();
        Review review = listingService.getReview(listing.getId(), $traveler.getId());
        System.out.println(review);
        if (review != null) {
            rating = review.getRating();
        } 

        for (Tag tag: listing.getTags()) {
            Long tagId = tag.getId();

            tagRatings.putIfAbsent(tagId, new ArrayList<>());
            tagRatings.get(tagId).add(rating);

            tagCounts.put(tagId, tagCounts.getOrDefault(tagId, 0) + 1);
        }
    }

    for (Object obj : $previousBookings) {
        Booking booking = (Booking) obj;
        Listing listing = booking.getListing();
        if ($favoriteListings.contains(listing)) {
            continue; 
        }

        double rating = listing.getRating();
        Review review = listingService.getReview(listing.getId(), $traveler.getId());
        System.out.println(review);
        if (review != null) {
            rating = review.getRating();
        } 

        for (Tag tag: listing.getTags()) {
            Long tagId = tag.getId();

            tagRatings.putIfAbsent(tagId, new ArrayList<>());
            tagRatings.get(tagId).add(rating);

            tagCounts.put(tagId, tagCounts.getOrDefault(tagId, 0) + 1);
        }
    }


    int countTag = 0;
    for (Map.Entry<Long, List<Double>> entry : tagRatings.entrySet()) {
        Long tagId = entry.getKey();
        List<Double> ratings = entry.getValue();
        double averageRating = ratings.stream().mapToDouble(Double::doubleValue).average().orElse(0.0);
        int count = tagCounts.get(tagId);

        TagFlag tagFlag = new TagFlag(tagId, averageRating, count, $event.getTimestamp());
        insert(tagFlag);
        System.out.println(tagFlag);
        countTag += 1;

        System.out.println("Created TagFlag for tag ID: " + tagId);
    }

    System.out.println("Number of tag flags created: " + countTag);
    
end

rule "Reward visited destinations"
salience 10
when
    $listing : Listing($destinationId : location.destination.id, $rating : rating > 7)
    $flag : DestinationFlag(destinationId == $destinationId, $timestamp: loginTimestamp)
then
    insert(new AccommodationPoints($listing, 10, $timestamp));
    System.out.println("Rewarded visited destination for listing with id " + $listing.getId());
end

rule "Reward frequent destinations"
salience 10
when
    $listing : Listing($destinationId : location.destination.id)
    $flag : DestinationFlag(destinationId == $destinationId, $count : count > 3, $timestamp: loginTimestamp)
then
    insert(new AccommodationPoints($listing, 5, $timestamp));
    System.out.println("Rewarded frequent destination for listing with id " + $listing.getId());
end

rule "Penalize nonvisited destinations"
salience 10
when
    $event: FetchListingRecomendationEvent($timestamp: timestamp)
    $listing : Listing($destinationId : location.destination.id)
    not DestinationFlag(destinationId == $destinationId, $timestamp == loginTimestamp)
then
    insert(new AccommodationPoints($listing, -5, $timestamp)); 
    System.out.println("Penalized nonvisited destination for listing with id " + $listing.getId());
end

rule "Penalize poorly rated destinations"
salience 10
when
    $listing : Listing($destinationId : location.destination.id)
    $flag : DestinationFlag(destinationId == $destinationId, averageRating < 7, $timestamp: loginTimestamp)
then
    insert(new AccommodationPoints($listing, -10, $timestamp));
    System.out.println("Penalized poorly rated destination for listing with id " + $listing.getId());
end

rule "Reward desireble tags"
salience 10
when
    $listing : Listing($listingId : id, $tags : tags)
    $tag : Tag() from $tags
    $flag : TagFlag(tagId == $tag.id, averageRating > 7, $timestamp: loginTimestamp)
then
    insert(new AccommodationPoints($listing, 10, $timestamp)); 
    System.out.println("Rewarded desireble tag for listing with id " + $listing.getId());
end

rule "Reward frequent tags"
salience 10
when
    $listing : Listing($listingId : id, $tags : tags)
    $tag : Tag() from $tags
    $flag : TagFlag(tagId == $tag.id, $count : count > 3, $timestamp: loginTimestamp)
then
    insert(new AccommodationPoints($listing, 5, $timestamp));
    System.out.println("Rewarded frequent tag for listing with id " + $listing.getId());
end

rule "Penalize nondesireble tags"
salience 10
when
    $event: FetchListingRecomendationEvent($timestamp: timestamp)
    $listing : Listing($listingId : id, $tags : tags)
    $tag : Tag() from $tags
    not TagFlag(tagId == $tag.id, $timestamp == loginTimestamp)
then
    insert(new AccommodationPoints($listing, -5, $timestamp));
    System.out.println("Penalized poorly rated tag for listing with id " + $listing.getId());
end

rule "Penalize badly rated tags"
salience 10
when
    $listing : Listing($listingId : id, $tags : tags)
    $tag : Tag() from $tags
    $flag : TagFlag(tagId == $tag.id, averageRating < 7, $timestamp: loginTimestamp)
then
    insert(new AccommodationPoints($listing, -10, $timestamp));
    System.out.println("Penalized poorly rated tag for listing with id " + $listing.getId());
end

rule "Penalize already booked listings"
salience 10
when
    $event: FetchListingRecomendationEvent($traveler: traveler, $timestamp: timestamp)
    $booking: Booking(traveler == $traveler)
then
    insert(new AccommodationPoints($booking.getListing(), -5, $timestamp));
    System.out.println("Penalized already booked listing with id " + $booking.getListing().getId());
end

rule "Accumulate points for listing"
salience 5
when
    $event: FetchListingRecomendationEvent($timestamp: timestamp)
    $listing : Listing($listingId : id)
    $points : Number(doubleValue : doubleValue) from accumulate(
        $point : AccommodationPoints(listing.id == $listingId, loginTimestamp == $timestamp),
        sum($point.getValue())
    )
then
    insert(new AccommodationRecommendation($listing, doubleValue, $timestamp));
    System.out.println("Inserted " + doubleValue + " sum points for listing with id " + $listingId);
end

rule "Rank and display top 10 listings"
salience 1
when
    $event: FetchListingRecomendationEvent($timestamp: timestamp)
    accumulate(
        $rec : AccommodationRecommendation($timestamp == loginTimestamp, value > 0),
        $top10 : collectList($rec)
    )
then
    delete($event);

    if ($top10.size() == 0) {
        System.out.println("No good recommendations found based on preference, returning trending.");
        insert(new RecommendTrendingAccommodationEvent($timestamp));
    } else {
        List<AccommodationRecommendation> mutableTop10 = new ArrayList<>($top10);
        Collections.sort(mutableTop10, (a, b) -> Double.compare(b.getValue(), a.getValue()));
        List<AccommodationRecommendation> top10 = mutableTop10.subList(0, Math.min(10, mutableTop10.size()));

        List<Listing> top10Listings = top10.stream()
                                               .map(AccommodationRecommendation::getListing)
                                               .collect(Collectors.toList());
       
        System.out.println("Recommended " + top10.size() + " listings.");

        insert(new AccommodationRecommendationResult(top10Listings, $timestamp));
       
    }
    
end

query "TopRatedListings"
    $listing : Listing()
    $rating : Double() from accumulate (
        $review : Review(listing.id == $listing.id),
        average($review.getRating())
    )
end

rule "Find trending listings"
salience 1
when
    $event: RecommendTrendingAccommodationEvent($timestamp: loginTimestamp)
then
    List<Listing> topRatedListings = new ArrayList<>();
    QueryResults results = kcontext.getKieRuntime().getQueryResults("TopRatedListings");
    for (QueryResultsRow row : results) {
        Listing listing = (Listing) row.get("$listing");
        topRatedListings.add(listing);
    }

    topRatedListings.sort((a, b) -> Double.compare(b.getRating(), a.getRating()));
    topRatedListings = topRatedListings.subList(0, Math.min(10, topRatedListings.size()));

    System.out.println("Recommended " + topRatedListings.size() + " trending listings.");

    insert(new AccommodationRecommendationResult(topRatedListings, $timestamp));
    delete($event);
end

// =========================================
// REVIEW LISTING - CEP

